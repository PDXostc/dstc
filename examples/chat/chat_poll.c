// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)

#include "dstc.h"
#include "rmc_log.h"
#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef USE_POLL
#error Please compile with USE_POLL
#endif

char g_username[128];

// Generate serializer functionality and the callable client function
// dstc_chat_message().
// A call to dstc_message will trigger a call to
// chat_message() in all nodes that have loaded this library.
//
DSTC_CLIENT(chat_message, char, [128], char, [512])

// Generate deserializer for multicast packets sent by dstc_chat_message()
// above.
// The deserializer decodes the incoming data and calls the
// chat_message() function in this file.
//
DSTC_SERVER(chat_message, char, [128], char, [512])

//
// Handle keyboard input on stdin.  called by dstc_node since init()
// (below) registered file descriptor 0 with the polling system.
//
static void handle_keyboard()
{
    char buf[512];

    if (!fgets(buf, sizeof(buf)-1, stdin)) {
        perror("fgets");
        exit(255);
    }
    buf[strlen(buf)-1] = 0; // Remove trailing newline

    // Distribute the input.
    // dstc_char_message() is the client side of chat_message() that
    // is generated by the DSTC_CLIENT() macro.
    //
    // dstc_chat_message() will:
    // 1. serialize username and buf
    // 2. Use reliable_multicast to send out the packet to other nodes.
    //
    // The receiving intsances of test_chat.so will:
    // 1. Deserialize incoming data to username and buf.
    // 2. Call chat_message(username, buf)
    //
    dstc_chat_message(g_username, buf);
}


//
// Process an incoming message with a message() function call.
// Invoked by deserilisation code generated by DSTC_SERVER() above.
//
void chat_message(char username[128], char buf[512])
{
    printf("\r[%s]: %s\n", username, buf);
    printf("> ");
    fflush(stdout);
}

int main(int argc, char* argv[])
{
    // Ask for username
    printf("Username: ");
    if (!fgets(g_username, sizeof(g_username)-1, stdin)) {
        perror("fgets");
        exit(255);
    }
    g_username[strlen(g_username)-1] = 0; // Remove trailing newline

    // Print initial prompt
    printf("> ");
    fflush(stdout);

    dstc_setup();

    // Wait for input and process
    while(1) {
        int timeout = 0;
        int nfds = 0;
        int vec_sz = 0;
        struct pollfd events[dstc_get_socket_count() + 1]; // Add 1 for our stdin.

        // Find out when our next timeout is.
        // If timeout is zero, then we need to process a timeout immediately.
        while (!(timeout = dstc_get_timeout_msec_rel())) {
            RMC_LOG_DEBUG("Got timeout in dstc_get_timeout_msec_rel()");
            dstc_process_timeout();
        }


        RMC_LOG_DEBUG("poll(): %d elements", sizeof(events)/sizeof(events[0]));
        if (dstc_retrieve_pollfd_vector(events,
                                        sizeof(events)/sizeof(events[0])-1,
                                        &vec_sz)) {

            RMC_LOG_FATAL("dstc_retrieve_pollfd_vector(): Failed.");
            exit(255);
        }

        // Add stdin at end of event vector
        events[vec_sz].fd = 0;
        events[vec_sz].events = 0;
        events[vec_sz].revents = 0;
        vec_sz++;
        // Wait for the given time.
        RMC_LOG_DEBUG("Entering poll with %d elements for %d msec", vec_sz,timeout);
        nfds = poll(events, vec_sz, timeout);

        // Timeout?
        if (nfds == 0) {
            // Process dstc events and try again.
            RMC_LOG_DEBUG("Got timeout in epoll_wait()");
            dstc_process_timeout();
            continue;
        }

        //
        // We have one or more triggered events.
        // Loop through them and process them as keyboard
        // or DSTC events.
        //
        while(vec_sz--) {
            if (!events[vec_sz].revents)
                continue;

            // Is this keyboard input?
            if (events[vec_sz].fd == 0) {
                handle_keyboard();
                continue;
            }

            // Is this a DSTC event?
            dstc_process_poll_result(&events[vec_sz]);
        }
    }
}
