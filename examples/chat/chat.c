// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the 
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)

#include <stdio.h>
#include "dstc.h"
#include <poll.h>

char g_username[128];

// Generate serializer functionality and the callable client function
// dstc_message().
// A call to dstc_message will trigger a call to
// message() in all nodes that have loaded this library.
//
DSTC_CLIENT(message, char, [128], char, [512])

// Generate deserializer for multicast packets sent by dstc_message()
// above.
// The deserializer decodes the incoming data and calls the
// message() function in this file.
//
DSTC_SERVER(message, char, [128], char, [512])

//
// Handle keyboard input on stdin.  called by dstc_node since init()
// (below) registered file descriptor 0 with the polling system.
//
static void handle_keyboard()
{
    char buf[512];

    fgets(buf, sizeof(buf)-1, stdin);
    buf[strlen(buf)-1] = 0; // Remove trailing newline

    // Distribute the input.
    // dstc_message() is the client side of message() that
    // is generated by the DSTC_CLIENT() macro.
    //
    // dstc_message() will:
    // 1. serialize username and buf
    // 2. Send out a multicast packet with 'message' and arguments.
    //
    // The receiving intsances of test_chat.so will:
    // 1. Deserialize incoming data to username and buf.
    // 2. Call message(username, buf)
    //
    dstc_message(g_username, buf);
}


//
// Process an incoming message with a message() function call.
// Invoked by deserilisation code generated by DSTC_SERVER() above.
//
void message(char username[128], char buf[512])
{
    printf("\r[%s]: %s\n", username, buf);
    printf("> ");
    fflush(stdout);
}

int main(int argc, char* argv[])
{
    struct pollfd pfd[2];

    // Ask for username
    printf("Username: ");
    fgets(g_username, sizeof(g_username)-1, stdin);
    g_username[strlen(g_username)-1] = 0; // Remove trailing newline

    // Print initial prompt
    printf("> ");
    fflush(stdout);

    // Setup poll vector for stdin keyboard and dstc socket.
    pfd[0].fd = 0; // Stdin
    pfd[0].events = POLLIN;

    pfd[1].fd = dstc_get_socket(); 
    pfd[1].events = POLLIN;
    
    // Wait for input and process
    while(1) {
        pfd[0].revents = 0;
        pfd[1].revents = 0;
        poll(pfd, 2, -1);

        if (pfd[0].revents) // Keyboard inut?
            handle_keyboard();

        if (pfd[1].revents) // Socket input
            dstc_read();
    }
}
