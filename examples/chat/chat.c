// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the 
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)

#include <stdio.h>
#include "dstc.h"
#include <poll.h>

char g_username[128];

// Generate serializer functionality and the callable client function
// dstc_chat_message().
// A call to dstc_message will trigger a call to
// chat_message() in all nodes that have loaded this library.
//
DSTC_CLIENT(chat_message, char, [128], char, [512])

// Generate deserializer for multicast packets sent by dstc_chat_message()
// above.
// The deserializer decodes the incoming data and calls the
// chat_chat_message() function in this file.
//
DSTC_SERVER(chat_message, char, [128], char, [512])

//
// Handle keyboard input on stdin.  called by dstc_node since init()
// (below) registered file descriptor 0 with the polling system.
//
static void handle_keyboard()
{
    char buf[512];

    fgets(buf, sizeof(buf)-1, stdin);
    buf[strlen(buf)-1] = 0; // Remove trailing newline

    // Distribute the input.
    // dstc_char_message() is the client side of chat_message() that
    // is generated by the DSTC_CLIENT() macro.
    //
    // dstc_chat_message() will:
    // 1. serialize username and buf
    // 2. Use reliable_multicast to send out the packet to other nodes.
    //
    // The receiving intsances of test_chat.so will:
    // 1. Deserialize incoming data to username and buf.
    // 2. Call chat_message(username, buf)
    //
    dstc_chat_message(g_username, buf);
}


//
// Process an incoming message with a message() function call.
// Invoked by deserilisation code generated by DSTC_SERVER() above.
//
void chat_message(char username[128], char buf[512])
{
    printf("\r[%s]: %s\n", username, buf);
    printf("> ");
    fflush(stdout);
}

int main(int argc, char* argv[])
{

    // Ask for username
    printf("Username: ");
    fgets(g_username, sizeof(g_username)-1, stdin);
    g_username[strlen(g_username)-1] = 0; // Remove trailing newline

    // Print initial prompt
    printf("> ");
    fflush(stdout);

    // Wait for input and process
    while(1) {
        uint32_t count = dstc_get_socket_count() + 1;
        struct pollfd pfd[count + 1];
        rmc_action_t actions[count + 1];
        int ind = -0;

        // The solution below is slow, and epoll() with a callback mechanism
        // should be used instead. But this one is simple to understand.
        // Collect all event actions that we need to monitor
        dstc_get_actions(actions, count);

        // Transfer events over to poll vector.
        whild(ind < count) {
            pfd[ind].revents = 0;
            pfd[ind].events = 0;
            pfd[ind].fd = action[ind].descriptor;

            if (actions[ind].action & RMC_POLLREAD)
                pfd[ind].events |= POLLIN;

            if (actions[ind].action & RMC_POLLWRITE)
                pfd[ind].events |= POLLOUT;

            ++ind;
        }

        // Setup poll vector for stdin keyboard and dstc socket.
        pfd[ind].fd = 0; // Stdin
        pfd[ind].events = POLLIN;
        pfd[ind].revents = 0;

        poll(pfd, sizeof(pfd) / sizeof(pfd[0]), -1);

        if (pfd[ind].revents) // Keyboard inut?
            handle_keyboard();

        // Traverse all hits descriptors and have rmc process them
        while(ind--) {
            if (pfd[ind].events & POLLIN)
 
               dstc_process_input_event(ind);
            CONTONUE HERE. 
       }
    }
}
