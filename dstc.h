// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the 
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)

// Thanks to https://codecraft.co/2014/11/25/variadic-macros-tricks for
// deciphering variadic macro iterations.
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <memory.h>

#define _GET_NTH_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, \
                     _11, _12, _13, _14, _15, _16, N, ...) N

#define _GET_ARG_COUNT(...) _GET_NTH_ARG(__VA_ARGS__, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)

// Smells like... Erlang!
#define _FE_0(...)
#define _FE_1(_call, x, ...) _call(1, x)
#define _FE_2(_call, x, ...) _call(2, x) _FE_1(_call, __VA_ARGS__)
#define _FE_3(_call, x, ...) _call(3, x) _FE_2(_call, __VA_ARGS__)
#define _FE_4(_call, x, ...) _call(4, x) _FE_3(_call, __VA_ARGS__)
#define _FE_5(_call, x, ...) _call(5, x) _FE_4(_call, __VA_ARGS__)
#define _FE_6(_call, x, ...) _call(6, x) _FE_5(_call, __VA_ARGS__)
#define _FE_7(_call, x, ...) _call(7, x) _FE_6(_call, __VA_ARGS__)
#define _FE_8(_call, x, ...) _call(8, x) _FE_7(_call, __VA_ARGS__)
#define _FE_9(_call, x, ...) _call(9, x) _FE_8(_call, __VA_ARGS__)
#define _FE_10(_call, x, ...) _call(10, x) _FE_9(_call, __VA_ARGS__)
#define _FE_11(_call, x, ...) _call(11, x) _FE_10(_call, __VA_ARGS__)
#define _FE_12(_call, x, ...) _call(12, x) _FE_11(_call, __VA_ARGS__)
#define _FE_13(_call, x, ...) _call(13, x) _FE_13(_call, __VA_ARGS__)
#define _FE_14(_call, x, ...) _call(14, x) _FE_14(_call, __VA_ARGS__)
#define _FE_15(_call, x, ...) _call(15, x) _FE_15(_call, __VA_ARGS__)
#define _FE_16(_call, x, ...) _call(16, x) _FE_16(_call, __VA_ARGS__)

#define FOR_EACH_VARIADIC_MACRO(_call, ...)                         \
      _GET_NTH_ARG(__VA_ARGS__,                                     \
                   _FE16, _FE15, _FE14, _FE13,                      \
                   _FE12, _FE11, _FE10, _FE9,                       \
                   _FE8,  _FE7,  _FE6,  _FE5,                       \
                   _FE_4, _FE_3, _FE_2, _FE_1, _FE_0)(_call, ##__VA_ARGS__)  


// List building variant where each output generated by _call(),
// except the last one, is trailed by a comma.
// Solves trailing comma issue
#define _LE_0(...)
#define _LE_1(_call, x, ...) _call(1, x)
#define _LE_2(_call, x, ...) _call(2, x) , _LE_1(_call, __VA_ARGS__) 
#define _LE_3(_call, x, ...) _call(3, x) , _LE_2(_call, __VA_ARGS__)
#define _LE_4(_call, x, ...) _call(4, x) , _LE_3(_call, __VA_ARGS__)
#define _LE_5(_call, x, ...) _call(5, x) , _LE_4(_call, __VA_ARGS__)
#define _LE_6(_call, x, ...) _call(6, x) , _LE_5(_call, __VA_ARGS__)
#define _LE_7(_call, x, ...) _call(7, x) , _LE_6(_call, __VA_ARGS__)
#define _LE_8(_call, x, ...) _call(8, x) , _LE_7(_call, __VA_ARGS__)
#define _LE_9(_call, x, ...) _call(9, x) , _LE_8(_call, __VA_ARGS__)
#define _LE_10(_call, x, ...) _call(10, x) , _LE_9(_call, __VA_ARGS__)
#define _LE_11(_call, x, ...) _call(11, x) , _LE_10(_call, __VA_ARGS__)
#define _LE_12(_call, x, ...) _call(12, x) , _LE_11(_call, __VA_ARGS__)
#define _LE_13(_call, x, ...) _call(13, x) , _LE_13(_call, __VA_ARGS__)
#define _LE_14(_call, x, ...) _call(14, x) , _LE_14(_call, __VA_ARGS__)
#define _LE_15(_call, x, ...) _call(15, x) , _LE_15(_call, __VA_ARGS__)
#define _LE_16(_call, x, ...) _call(16, x) , _LE_16(_call, __VA_ARGS__)

#define FOR_EACH_VARIADIC_MACRO_ELEM(_call, ...)             \
      _GET_NTH_ARG(__VA_ARGS__,                                     \
                   _LE16, _LE15, _LE14, _LE13,                      \
                   _LE12, _LE11, _LE10, _LE9,                       \
                   _LE8,  _LE7,  _LE6,  _LE5,                       \
                   _LE_4, _LE_3, _LE_2, _LE_1, _LE_0)(_call, ##__VA_ARGS__)  


#define SERIALIZE_ARGUMENT(arg_id, arg)                                  \
    memcpy((void*) data, (void*) &_a##arg_id, sizeof(arg));       \
    data += sizeof(arg);                                  

#define DESERIALIZE_ARGUMENT(arg_id, arg)                                \
  memcpy((void*) &_a##arg_id, (void*) data,sizeof(arg));          \
  data += sizeof(arg);                                  

#define DECLARE_ARGUMENT(arg_id, type) type _a##arg_id                                          
#define LIST_ARGUMENT(arg_id, type) _a##arg_id                                          
#define DECLARE_VARIABLE(arg_id, type) type _a##arg_id;                                          
#define SIZE_ARGUMENT(arg_id, arg)     sizeof(arg) +                                            

#define SERIALIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(SERIALIZE_ARGUMENT, ##__VA_ARGS__)
#define DESERIALIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(DESERIALIZE_ARGUMENT, ##__VA_ARGS__)
#define DECLARE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO_ELEM(DECLARE_ARGUMENT, ##__VA_ARGS__)
#define LIST_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO_ELEM(LIST_ARGUMENT, ##__VA_ARGS__)
#define DECLARE_VARIABLES(...) FOR_EACH_VARIADIC_MACRO(DECLARE_VARIABLE, ##__VA_ARGS__)
#define SIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(SIZE_ARGUMENT, ##__VA_ARGS__)

// Create client function that serializes and writes to descriptor
// Create server function that receives serialized data on descriptor
// and makes call.
//
// Namespaces in dlmopen are used to avoid duplicate dstc_get_functions()
// clashes when multiple shared objects are loaded.
// LIMITATION: ONLY ONE DSTC_FUNCTION() CALL PER SO FILE. FOR NOW.
//
#define DSTC_CLIENT(name, ...)                                          \
    void dstc_##name(int32_t desc, DECLARE_ARGUMENTS(__VA_ARGS__)) {    \
        uint32_t sz = SIZE_ARGUMENTS(__VA_ARGS__) 0;                    \
        uint8_t buffer[sz];                                             \
        uint8_t *data= buffer;                                          \
        uint16_t name_len = sizeof(#name);                              \
        write(desc, (void*) &name_len, sizeof(name_len));               \
        write(desc, (void*) #name, sizeof(#name));                      \
        SERIALIZE_ARGUMENTS(__VA_ARGS__) ;                              \
        write(desc, buffer, sz);                                        \
    }                                                                   \



#define DSTC_SERVER(name, ...)                                          \
    static void dstc_server_##name(int32_t desc) {                      \
        uint32_t sz = SIZE_ARGUMENTS(__VA_ARGS__) 0;                    \
        uint8_t buffer[sz];                                             \
        uint8_t *data= buffer;                                          \
                                                                        \
        DECLARE_VARIABLES(__VA_ARGS__)                                  \
        ssize_t res = read(desc, buffer, sz);                           \
        DESERIALIZE_ARGUMENTS(__VA_ARGS__)                              \
                                                                        \
        name(LIST_ARGUMENTS(__VA_ARGS__));                              \
        return;                                                         \
    }                                                                   \
                                                                        \
    static void __attribute__((constructor)) _dstc_register_##name() {  \
        extern void dstc_register_function(char*, void (*)(int32_t));   \
        dstc_register_function(#name, dstc_server_##name);              \
    }

