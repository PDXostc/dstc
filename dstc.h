// Copyright (C) 2018, Jaguar Land Rover
// This program is licensed under the terms and conditions of the
// Mozilla Public License, version 2.0.  The full text of the 
// Mozilla Public License is at https://www.mozilla.org/MPL/2.0/
//
// Author: Magnus Feuer (mfeuer1@jaguarlandrover.com)

// Thanks to https://codecraft.co/2014/11/25/variadic-macros-tricks for
// deciphering variadic macro iterations.
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <memory.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define _GET_NTH_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, \
                     _11, _12, _13, _14, _15, _16, N, ...) N

#define _GET_ARG_COUNT(...) _GET_NTH_ARG(__VA_ARGS__, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)

// Smells like... Erlang!
#define _FE0(_call)
#define _FE2(_call, type, size, ...) _call(1, type, size) 
#define _FE4(_call, type, size, ...) _call(2, type, size) _FE2(_call, __VA_ARGS__)
#define _FE6(_call, type, size, ...) _call(3, type, size) _FE4(_call, __VA_ARGS__)
#define _FE8(_call, type, size, ...) _call(4, type, size) _FE7(_call, __VA_ARGS__)
#define _FE10(_call, type, size, ...) _call(5, type, size) _FE9(_call, __VA_ARGS__)
#define _FE12(_call, type, size, ...) _call(6, type, size) _FE11(_call, __VA_ARGS__)
#define _FE14(_call, type, size, ...) _call(7, type, size) _FE14(_call, __VA_ARGS__)
#define _FE16(_call, type, size, ...) _call(8, type, size) _FE16(_call, __VA_ARGS__)
#define _ERR(...) "Declare arguments in pairs: (char, [16]). Leave size empty if not array (char,)"

#define FOR_EACH_VARIADIC_MACRO(_call, ...)                             \
    _GET_NTH_ARG(__VA_ARGS__,                                           \
                 _FE16, _ERR, _FE14, _ERR,                              \
                 _FE12, _ERR, _FE10, _ERR,                              \
                 _FE8,  _ERR, _FE6,  _ERR,                              \
                 _FE4,  _ERR, _FE2,  _ERR, _FE0)(_call, ##__VA_ARGS__)  


// List building variant where each output generated by _call(),
// except the last one, is trailed by a comma.
// Solves trailing comma issue
#define _LE2(_call, type, size, ...) _call(1, type, size) 
#define _LE4(_call, type, size, ...) _call(2, type, size) , _LE2(_call, __VA_ARGS__)
#define _LE6(_call, type, size, ...) _call(3, type, size) , _LE4(_call, __VA_ARGS__)
#define _LE8(_call, type, size, ...) _call(4, type, size) , _LE6(_call, __VA_ARGS__)
#define _LE10(_call, type, size, ...) _call(5, type, size) , _LE8(_call, __VA_ARGS__)
#define _LE12(_call, type, size, ...) _call(6, type, size) , _LE10(_call, __VA_ARGS__)
#define _LE14(_call, type, size, ...) _call(7, type, size) , _LE12(_call, __VA_ARGS__)
#define _LE16(_call, type, size, ...) _call(8, type, size) , _LE14(_call, __VA_ARGS__)

#define FOR_EACH_VARIADIC_MACRO_ELEM(_call, ...)                        \
    _GET_NTH_ARG(__VA_ARGS__,                                           \
                 _LE16, _ERR, _LE14, _ERR,                              \
                 _LE12, _ERR, _LE10, _ERR,                              \
                 _LE8,  _ERR, _LE6,  _ERR,                              \
                 _LE4,  _ERR, _LE2,  _ERR, _LE0)(_call, ##__VA_ARGS__)  

#define SERIALIZE_ARGUMENT(arg_id, type, size)                          \
    if (sizeof(type size ) == sizeof(type))                             \
        memcpy((void*) data, (void*) &_a##arg_id, sizeof(type size));   \
    else                                                                \
        memcpy((void*) data, (void*) _a##arg_id, sizeof(type size));    \
    data += sizeof(type size);                                          \

#define DESERIALIZE_ARGUMENT(arg_id, type, size)                        \
    if (sizeof(type size) == sizeof(type))                           \
        memcpy((void*) &_a##arg_id, (void*) data, sizeof(type size));   \
    else                                                                \
        memcpy((void*) _a##arg_id, (void*) data, sizeof(type size));    \
    data += sizeof(type size);                                          \


#define DECLARE_ARGUMENT(arg_id, type, size) type _a##arg_id size
#define LIST_ARGUMENT(arg_id, type, size) _a##arg_id
#define DECLARE_VARIABLE(arg_id, type, size) type _a##arg_id size ;
#define SIZE_ARGUMENT(arg_id, type, size)     sizeof(type size) +                                            

#define SERIALIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(SERIALIZE_ARGUMENT, ##__VA_ARGS__)
#define DESERIALIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(DESERIALIZE_ARGUMENT, ##__VA_ARGS__)
#define DECLARE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO_ELEM(DECLARE_ARGUMENT, ##__VA_ARGS__)
#define LIST_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO_ELEM(LIST_ARGUMENT, ##__VA_ARGS__)
#define DECLARE_VARIABLES(...) FOR_EACH_VARIADIC_MACRO(DECLARE_VARIABLE, ##__VA_ARGS__)
#define SIZE_ARGUMENTS(...) FOR_EACH_VARIADIC_MACRO(SIZE_ARGUMENT, ##__VA_ARGS__)

#define DSTC_MCAST_GROUP "239.0.0.1"
#define DSTC_MCAST_PORT 4723

// Create client function that serializes and writes to descriptor
// Create server function that receives serialized data on descriptor
// and makes call.
//
// Namespaces in dlmopen are used to avoid duplicate dstc_get_functions()
// clashes when multiple shared objects are loaded.
// LIMITATION: ONLY ONE DSTC_FUNCTION() CALL PER SO FILE. FOR NOW.
//
#define DSTC_CLIENT(name, ...)                                          \
    void dstc_##name(DECLARE_ARGUMENTS(__VA_ARGS__)) {                  \
        uint32_t sz = SIZE_ARGUMENTS(__VA_ARGS__) sizeof(#name);        \
        uint8_t buffer[sz];                                             \
        uint8_t *data = buffer + sizeof(#name);                         \
        extern void dstc_srv_send(uint8_t* buffer, uint32_t sz);        \
                                                                        \
        strcpy(buffer, #name);                                          \
        SERIALIZE_ARGUMENTS(__VA_ARGS__)                                \
        dstc_srv_send(buffer, sz);                                      \
    }                                                                   \

#define DSTC_SERVER(name, ...)                                          \
    static void dstc_server_##name(uint8_t* data)                       \
    {                                                                   \
        extern void name(DECLARE_ARGUMENTS(__VA_ARGS__));               \
        DECLARE_VARIABLES(__VA_ARGS__)                                  \
        DESERIALIZE_ARGUMENTS(__VA_ARGS__)                              \
        name(LIST_ARGUMENTS(__VA_ARGS__));                              \
        return;                                                         \
    }                                                                   \
                                                                        \
    static void __attribute__((constructor)) _dstc_register_##name()    \
    {                                                                   \
        extern void dstc_register_function(char*, void (*)(uint8_t*));  \
        dstc_register_function(#name, dstc_server_##name);              \
    }

#define DSTC_ON_LOAD(name)                                              \
    static void __attribute__((constructor)) _dstc_on_load_##name()     \
    {                                                                   \
        extern void name(void);                                         \
        name();                                                         \
    }

typedef void (*dstc_epoll_cb_t) (int fd, struct epoll_event* ev) ;

extern void dstc_epoll_ctl(int op,
                           int fd,
                           struct epoll_event* ev,
                           dstc_epoll_cb_t callback);

